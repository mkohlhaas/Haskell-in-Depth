{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -ddump-splices #-}

import Control.Monad.State (MonadIO (liftIO), MonadState (get), modify)
import PingCommon (PingAnswer (..), RemotePing)
import ServerUtils (genServer, runSerialized, serveRPC)

-- `liftIO` can be used whenever we have a monad stack where the base monad is IO!

ping ∷ RemotePing PingAnswer
ping = do
  modify (+ 1)
  n ← get
  liftIO $ putStrLn $ "Ping received. Answered with " <> show n <> "."
  pure $ PingAnswer "OK" n

echo ∷ String → RemotePing String
echo msg = do
  liftIO $ putStrLn $ "Echo message: " <> msg
  pure msg

echo1 ∷ String → String → RemotePing String
echo1 msg1 msg2 = do
  liftIO $ putStrLn $ "Echo message: " <> msg1
  pure msg1

echo2 ∷ String → String → String → RemotePing String
echo2 msg1 msg2 msg3 = do
  liftIO $ putStrLn $ "Echo message: " <> msg1
  pure msg1

genServer ['ping, 'echo, 'echo1, 'echo2]

-- NOTE how we refer to the declared functions with 'ping and 'echo. The tick here is used
-- to get the TH Name of the corresponding functions. Remember, we've used double ticks to
-- refer to type names before. Note also that there is no explicit Template Haskell splice
-- for genServer here. GHC allows calling TH functions as top-level declarations without
-- the $(...) syntax.

-- This will be generated by TH (cleaned up):
-- server ∷ String → PortNumber → IO ()
-- server host port
--   = serveRPC host port
--       [("ping",  (runSerialized $ (const ∷ a → () → a) ping)),
--        ("echo",  (runSerialized $ id echo)),
--        ("echo1", (runSerialized $ (uncurry . id) echo1)),
--        ("echo2", (runSerialized $ (uncurry . (uncurry . id)) echo2))]

main ∷ IO ()
main = server "localhost" 1500
