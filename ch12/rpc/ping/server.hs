{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -ddump-splices #-}

import Control.Monad.State (MonadIO (liftIO), MonadState (get), modify)
import PingCommon (PingAnswer (..), RemotePing)
import ServerUtils (genServer, runSerialized, serveRPC)

-- `liftIO` can be used whenever we have a monad stack where the base monad is IO!

ping ∷ RemotePing PingAnswer
ping = do
  modify (+ 1)
  n ← get
  liftIO $ putStrLn $ "Ping received. Answered with " <> show n <> "."
  pure $ PingAnswer "OK" n

echo ∷ String → RemotePing String
echo msg = do
  liftIO $ putStrLn $ "Echo message: " <> msg
  pure msg

genServer ['ping, 'echo]

-- NOTE how we refer to the declared functions with 'ping and 'echo. The tick here is used
-- to get the TH Name of the corresponding functions. Remember, we've used double ticks to
-- refer to type names before. Note also that there is no explicit Template Haskell splice
-- for genServer here. GHC allows calling TH functions as top-level declarations without
-- the $(...) syntax.

-- This will be generated by TH (cleaned up):
-- server ∷ String → PortNumber → IO ()
-- server host port
--   = serveRPC host port [("ping", (runSerialized $ (const ∷ a → () → a) ping)),
--                         ("echo", (runSerialized $ id echo))]

main ∷ IO ()
main = server "localhost" 1500
